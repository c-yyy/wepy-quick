'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _event = require('./event');

var _event2 = _interopRequireDefault(_event);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Props = {
    check: function check(t, val) {
        switch (t) {
            case String:
                return typeof val === 'string';
            case Number:
                return typeof val === 'number';
            case Boolean:
                return typeof val === 'boolean';
            case Function:
                return typeof val === 'function';
            case Object:
                return (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
            case Array:
                return toString.call(val) === '[object Array]';
            default:
                return val instanceof t;
        }
    },
    build: function build(props) {
        var rst = {};
        if (typeof props === 'string') {
            rst[props] = {};
        } else if (toString.call(props) === '[object Array]') {
            props.forEach(function (p) {
                rst[p] = {};
            });
        } else {
            Object.keys(props).forEach(function (p) {
                if (typeof props[p] === 'function') {
                    rst[p] = {
                        type: [props[p]]
                    };
                } else if (toString.call(props[p]) === '[object Array]') {
                    rst[p] = {
                        type: props[p]
                    };
                } else rst[p] = props[p];

                if (rst[p].type && toString.call(rst[p].type) !== '[object Array]') rst[p].type = [rst[p].type];
            });
        }
        return rst;
    },
    valid: function valid(props, key, val) {
        var _this = this;

        var valid = false;
        if (props[key]) {
            if (!props[key].type) {
                valid = true;
            } else {
                return props[key].type.some(function (t) {
                    return _this.check(t, val);
                });
            }
        }
        return valid;
    },
    getValue: function getValue(props, key, value) {
        var rst;
        if (value !== undefined && this.valid(props, key, value)) {
            rst = value;
        } else if (typeof props[key].default === 'function') {
            rst = props[key].default();
        } else rst = props[key].default;
        return props[key].coerce ? props[key].coerce(rst) : rst;
    }
};

var _class = function () {
    function _class() {
        _classCallCheck(this, _class);

        this.$com = {};
        this.$mixins = [];
        this.$isComponent = true;
        this.$prefix = '';
        this.$mappingProps = {};
        this.data = {};
        this.methods = {};
    }

    _class.prototype.$init = function $init($wxpage, $root, $parent) {
        var _this2 = this;

        var self = this;

        this.$wxpage = $wxpage;
        if (this.$isComponent) {
            this.$root = $root || this.$root;
            this.$parent = $parent || this.$parent;
            this.$wxapp = this.$root.$parent.$wxapp;
            this.$app = this.$root.$app;
        }

        var coms = Object.getOwnPropertyNames(this.$com);
        if (coms.length) {
            coms.forEach(function (name) {
                _this2.$com[name].$init($wxpage, $root, _this2);
            });
        }

        return;
    };

    _class.prototype.initMixins = function initMixins() {
        var _this3 = this;

        if (this.mixins) {
            if (typeof this.mixins === 'function') {
                this.mixins = [this.mixins];
            }
        } else {
            this.mixins = [];
        }
        this.mixins.forEach(function (mix) {
            var inst = new mix();
            inst.init(_this3);
            _this3.$mixins.push(inst);
        });
    };

    _class.prototype.onLoad = function onLoad() {};

    _class.prototype.setData = function setData(k, v) {
        if (typeof k === 'string') {
            this.$vm[k] = v;
        }
        for (var t in k) {
            this.$vm[t] = k[t];
        }
    };

    _class.prototype.getWxPage = function getWxPage() {
        return this.$wxpage;
    };

    _class.prototype.getCurrentPages = function getCurrentPages() {
        return this.$wxpage.getCurrentPages();
    };

    _class.prototype.$getComponent = function $getComponent(com) {
        var _this4 = this;

        if (typeof com === 'string') {
            if (com.indexOf('/') === -1) {
                return this.$com[com];
            } else if (com === '/') {
                return this.$parent;
            } else {
                var path = com.split('/');
                path.forEach(function (s, i) {
                    if (i === 0) {
                        if (s === '') {
                            com = _this4.$root;
                        } else if (s === '.') {
                            com = _this4;
                        } else if (s === '..') {
                            com = _this4.$parent;
                        } else {
                            com = _this4.$getComponent(s);
                        }
                    } else if (s) {
                        com = com.$com[s];
                    }
                });
            }
        }
        return (typeof com === 'undefined' ? 'undefined' : _typeof(com)) !== 'object' ? null : com;
    };

    _class.prototype.$invoke = function $invoke(com, method) {
        com = this.$getComponent(com);

        if (!com) {
            throw new Error('Invalid path: ' + com);
        }

        var fn = com.methods ? com.methods[method] : '';

        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
        }

        if (typeof fn === 'function') {
            var $evt = new _event2.default('', this, 'invoke');
            var rst = fn.apply(com, args.concat($evt));
            com.$apply();
            return rst;
        } else {
            fn = com[method];
        }

        if (typeof fn === 'function') {
            return fn.apply(com, args);
        } else {
            throw new Error('Invalid method: ' + method);
        }
    };

    _class.prototype.$broadcast = function $broadcast(evtName) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
        }

        var com = this;
        var $evt = typeof evtName === 'string' ? new _event2.default(evtName, this, 'broadcast') : $evt;
        var queue = [com];

        while (queue.length && $evt.active) {
            var current = queue.shift();

            var _loop = function _loop(_c) {
                _c = current.$com[_c];
                queue.push(_c);
                var fn = getEventsFn(_c, evtName);
                if (fn) {
                    _c.$apply(function () {
                        fn.apply(_c, args.concat($evt));
                    });
                }
                if (!$evt.active) return 'break';
                c = _c;
            };

            for (var c in current.$com) {
                var _ret = _loop(c);

                if (_ret === 'break') break;
            }
        }
    };

    _class.prototype.$emit = function $emit(evtName) {
        var _this5 = this;

        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
        }

        var com = this;
        var source = this;
        var $evt = new _event2.default(evtName, source, 'emit');

        if (this.$parent.$events && this.$parent.$events[this.$name]) {
            var method = this.$parent.$events[this.$name]['v-on:' + evtName];
            if (method && this.$parent.methods) {
                var _fn = this.$parent.methods[method];
                if (typeof _fn === 'function') {
                    this.$parent.$apply(function () {
                        _fn.apply(_this5.$parent, args.concat($evt));
                    });
                    return;
                } else {
                    throw new Error('Invalid method from emit, component is ' + this.$parent.$name + ', method is ' + method + '. Make sure you defined it already.\n');
                }
            }
        }

        var _loop2 = function _loop2() {
            var comContext = com;
            var fn = getEventsFn(comContext, evtName);
            fn && comContext.$apply(function () {
                fn.apply(comContext, args.concat($evt));
            });
            com = comContext.$parent;
        };

        while (com && com.$isComponent !== undefined && $evt.active) {
            _loop2();
        }
    };

    _class.prototype.$apply = function $apply(fn) {
        if (typeof fn === 'function') {
            fn.call(this);
            this.$apply();
        } else {
            return true;
            if (this.$$phase) {
                this.$$phase = '$apply';
            } else {
                this.$digest();
            }
        }
    };

    _class.prototype.$digest = function $digest() {
        var _this6 = this;

        var k = void 0;
        var originData = this.$data;
        this.$$phase = '$digest';
        while (this.$$phase) {
            var readyToSet = {};
            for (k in originData) {
                if (!_util2.default.$isEqual(this[k], originData[k])) {
                    readyToSet[this.$prefix + k] = this[k];
                    this.data[k] = this[k];
                    originData[k] = _util2.default.$copy(this[k], true);
                    if (this.$mappingProps[k]) {
                        Object.keys(this.$mappingProps[k]).forEach(function (changed) {
                            var mapping = _this6.$mappingProps[k][changed];
                            if ((typeof mapping === 'undefined' ? 'undefined' : _typeof(mapping)) === 'object') {
                                _this6.$parent.$apply();
                            } else if (changed === 'parent' && !_util2.default.$isEqual(_this6.$parent.$data[mapping], _this6[k])) {
                                _this6.$parent[mapping] = _this6[k];
                                _this6.$parent.data[mapping] = _this6[k];
                                _this6.$parent.$apply();
                            } else if (changed !== 'parent' && !_util2.default.$isEqual(_this6.$com[changed].$data[mapping], _this6[k])) {
                                _this6.$com[changed][mapping] = _this6[k];
                                _this6.$com[changed].data[mapping] = _this6[k];
                                _this6.$com[changed].$apply();
                            }
                        });
                    }
                }
            }
            if (Object.keys(readyToSet).length) {
                if (this.computed) {
                    for (k in this.computed) {
                        var _fn2 = this.computed[k],
                            val = _fn2.call(this);
                        if (!_util2.default.$isEqual(this[k], val)) {
                            readyToSet[this.$prefix + k] = val;
                            this[k] = _util2.default.$copy(val, true);
                        }
                    }
                }
                this.setData(readyToSet);
            }
            this.$$phase = this.$$phase === '$apply' ? '$digest' : false;
        }
    };

    return _class;
}();

exports.default = _class;


function getEventsFn(comContext, evtName) {
    var fn = comContext.events ? comContext.events[evtName] : undefined;
    var typeFn = typeof fn === 'undefined' ? 'undefined' : _typeof(fn);
    var fnFn = void 0;
    if (typeFn === 'string') {
        var method = comContext.methods && comContext.methods[fn];
        if (typeof method === 'function') {
            fnFn = method;
        }
    } else if (typeFn === 'function') {
        fnFn = fn;
    }
    return fnFn;
}